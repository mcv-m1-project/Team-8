function [windowTP, windowFP, windowFN] = TrafficSignDetectionXCorr(valid_dir, ...
                                                      patterns, ...
                                                      pyr_scales, ...
                                                      xcorr_thr, ...
                                                      overlap_thr, ...
                                                      result_subdir)
% TrafficSignDetectionXCorr
%
% Validation test for template matching using cross correlation.
% It use the global approach proposed in Block 4 slides.
% 
%  function [pixels_results, window_results] = TrafficSignDetectionXCorr(...)
% 
%    Parameter name      Value
%    --------------      -----
%    valid_dir           The folder with the validation dataset. It
%                        must be contain a pixelCandidates/
%                        subfolder, with the images generated by
%                        the Block 2 detector (color segmentation +
%                        morphology).
%    patterns            Cell array with the pattern images.
%    pyr_scales          Row vector with the scales to build the
%                        pyramid. The first scale must be the
%                        biggest.
%    overlap_thr         Overlap threshold to apply in non maximum
%                        suppresion.
%    xcorr_thr           Minimum value in a cross correlation
%                        result to consider a positive matching
%                        between an image and a pattern.
%    result_subdir       Optional parameter. String with the folder name
%                        where to store the validation
%                        results. For each image several rects are
%                        drawn, with the TP, FP and FN results.
%                        The folder is created in valid_dir.

    input_files = ListFiles([valid_dir, '/pixelCandidates/']);
    im_files = ListFiles(valid_dir);
    
    if size(input_files, 1) ~= size(im_files, 1)
        error(['valid_dir: gt/ and pixeldet/ subdirs does not match']);
    end
    
    if exist('result_subdir', 'var')
        mkdir([valid_dir, '/', result_subdir]);
    else
        result_subdir = '';
    end

    pixelTP = 0;
    pixelFP = 0;
    pixelFN = 0;
    pixelTN = 0;
    windowTP = 0;
    windowFP = 0;
    windowFN = 0;
    tic
    for i=1:size(im_files, 1)
        fprintf('.');
        
        gt_file = ['gt.', im_files(i).name(1:end-3), 'txt'];
        windowAnnotations = LoadAnnotations([valid_dir, '/gt/', gt_file]);
        
        mask_file = ['mask.', im_files(i).name(1:end-3), 'png'];
        pixelAnnotation = imread([valid_dir, '/mask/', mask_file]);
        
        im = imread([valid_dir, '/pixelCandidates/', input_files(i).name]);
        im_downsmpl = imresize(im, 1/3);  % Time optimization
        
        pyr = Pyramid(im_downsmpl, pyr_scales);
        [bboxarr, score] = XCorrTemplateMatching(pyr, ...
                                                 patterns, ...
                                                 xcorr_thr);
        bboxarr = NonMaximumSuppression(bboxarr, ...
                                        score, ...
                                        overlap_thr);
        
        % Restore original size and coords
        bboxarr = round(bboxarr * 3);  
                                       
        % Adjust bbox to the image dimensions
        [h, w] = size(im);
        for j = 1:size(bboxarr, 1)            
            bboxarr(j, 1) = max(1, bboxarr(j, 1));
            bboxarr(j, 2) = max(1, bboxarr(j, 2));
            x2 = bboxarr(j, 1) + bboxarr(j, 3);
            y2 = bboxarr(j, 2) + bboxarr(j, 4);
            if w < x2
                bboxarr(j, 3) = bboxarr(j, 3) - (x2 - w);
            end
            if h < y2
                bboxarr(j, 4) = bboxarr(j, 4) - (y2 - h);
            end
        end
        
         % Convert bounding boxes to proper format (array of structs)
        bboxes = BoundingBoxesToStruct(bboxarr);
        
        % Filter pixel mask with detected windows
        pixelCandidates = filterWindowMask(im, bboxes);
        
        % Compute performance (object level)
        [localTP, localFN, localFP] = PerformanceAccumulationWindow(bboxes, ...
                                                          windowAnnotations);
        windowTP = windowTP + localTP;
        windowFP = windowFP + localFP;
        windowFN = windowFN + localFN;
        
        % Compute performance (pixel level)
        [localTP, localFP, localFN, localTN] = ...
            PerformanceAccumulationPixel(pixelCandidates, ...
                                         pixelAnnotation);
        pixelTP = pixelTP + localTP;
        pixelFP = pixelFP + localFP;
        pixelFN = pixelFN + localFN;
        pixelTN = pixelTN + localTN;
       
        if ~isempty(result_subdir)
            imresult = DrawBoundingBoxes(im, bboxes, windowAnnotations);
            imwrite(imresult, ...
                    [valid_dir, '/', result_subdir, '/', ...
                     input_files(i).name]);
        end
    end
    
    toc
    fprintf('\n');
    fprintf('time/frame (ms): %f\n', toc/size(im_files, 1));

    fprintf('pixel results:\n');
    fprintf('- TP, FP, FN, TN: %d, %d, %d, %d \n', ...
            pixelTP, pixelFP, pixelFN, pixelTN);
   
     [prec, acc, specf, rec] = PerformanceEvaluationPixel(pixelTP, ...
                                                       pixelFP, ...
                                                       pixelFN, pixelTN);
     fprintf('- prec, acc, specf, rec: %f, %f, %f, %f \n\n', ...
             prec, acc, specf, rec);
end